// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package providersdkv2

import (
	"context"
	"log"
	"strings"

	networkmodels "github.com/hashicorp/hcp-sdk-go/clients/cloud-network/stable/2020-09-07/models"
	sharedmodels "github.com/hashicorp/hcp-sdk-go/clients/cloud-shared/v1/models"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-hcp/internal/clients"
)

func resourcePrivateLink() *schema.Resource {
	return &schema.Resource{
		Description:   "The private link resource allows you to manage a private link within an HVN.",
		CreateContext: resourcePrivateLinkCreate,
		ReadContext:   resourcePrivateLinkRead,
		UpdateContext: resourcePrivateLinkUpdate,
		DeleteContext: resourcePrivateLinkDelete,
		Timeouts: &schema.ResourceTimeout{
			Default: &privateLinkDefaultTimeout,
			Create:  &privateLinkCreateTimeout,
			Delete:  &privateLinkDeleteTimeout,
			Update:  &privateLinkUpdateTimeout,
		},
		Importer: &schema.ResourceImporter{
			StateContext: resourcePrivateLinkImport,
		},
		Schema: map[string]*schema.Schema{
			// Required inputs
			"hvn_id": {
				Description: "The ID of the HVN associated with the private link.",
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
			},
			"private_link_id": {
				Description: "The ID of the private link.",
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
			},
			"vault_cluster_id": {
				Description: "The ID of the HCP Vault cluster associated with the private link.",
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
			},
			// Optional inputs
			"project_id": {
				Description: "The ID of the HCP project where the private link is located. If not specified, the project configured in the provider is used.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			"consumer_regions": {
				Description: "The cloud provider regions from which consumers can connect to the private link.",
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"consumer_accounts": {
				Description: "The list of consumer accounts allowed to connect to the private link. In AWS, these are IAM Principals. In Azure, these are Azure Subscription/Resource IDs.",
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"consumer_ip_ranges": {
				Description: "The list of consumer IP ranges or CIDRs allowed to connect to the HVD cluster associated with the private link.",
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			// Computed outputs
			"organization_id": {
				Description: "The ID of the HCP organization where the private link is located.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"created_at": {
				Description: "The time that the private link was created.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"updated_at": {
				Description: "The time that the private link was last updated.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"state": {
				Description: "The state of the private link.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"external_name": {
				Description: "The private link name generated by the cloud provider. In AWS, this is the name of the VPC Endpoint Service.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"self_link": {
				Description: "A unique URL identifying the private link.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"default_region": {
				Description: "The default region for the private link, which is the HVN region. This is automatically added as a consumer region.",
				Type:        schema.TypeString,
				Computed:    true,
			},
		},
	}
}

func resourcePrivateLinkCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*clients.Client)

	var err error
	// Updates the source channel to include data about the module used.
	client, err = client.UpdateSourceChannel(d)
	if err != nil {
		log.Printf("[DEBUG] Failed to update analytics with module name (%s)", err)
	}

	privateLinkID := d.Get("private_link_id").(string)
	hvnID := d.Get("hvn_id").(string)
	vaultClusterID := d.Get("vault_cluster_id").(string)
	projectID, err := GetProjectID(d.Get("project_id").(string), client.Config.ProjectID)
	if err != nil {
		return diag.Errorf("unable to retrieve project ID: %v", err)
	}

	loc := &sharedmodels.HashicorpCloudLocationLocation{
		OrganizationID: client.Config.OrganizationID,
		ProjectID:      projectID,
	}

	// Get the HVN to get its region information
	hvn, err := clients.GetHvnByID(ctx, client, loc, hvnID)
	if err != nil {
		return diag.Errorf("unable to retrieve HVN (%s): %v", hvnID, err)
	}

	// Create the HVN link with region information
	hvnLink := newLink(loc, HvnResourceType, hvnID)
	hvnLink.Location.Region = &sharedmodels.HashicorpCloudLocationRegion{
		Provider: hvn.Location.Region.Provider,
		Region:   hvn.Location.Region.Region,
	}

	// Extract consumer regions
	var consumerRegions []string
	if v, ok := d.GetOk("consumer_regions"); ok {
		for _, region := range v.([]interface{}) {
			if region != nil {
				consumerRegions = append(consumerRegions, region.(string))
			}
		}
	}

	// Extract consumer accounts
	var consumerAccounts []string
	if v, ok := d.GetOk("consumer_accounts"); ok {
		for _, account := range v.([]interface{}) {
			if account != nil {
				consumerAccounts = append(consumerAccounts, account.(string))
			}
		}
	}

	// Extract consumer IP ranges
	var consumerIPRanges []string
	if v, ok := d.GetOk("consumer_ip_ranges"); ok {
		for _, ipRange := range v.([]interface{}) {
			if ipRange != nil {
				consumerIPRanges = append(consumerIPRanges, ipRange.(string))
			}
		}
	}

	// Create the private link service model
	privateLinkService := &networkmodels.HashicorpCloudNetwork20200907PrivateLinkService{
		ID:               privateLinkID,
		Hvn:              hvnLink,
		VaultClusterID:   vaultClusterID,
		ConsumerRegions:  consumerRegions,
		ConsumerAccounts: consumerAccounts,
		ConsumerIPRanges: consumerIPRanges,
	}

	log.Printf("[INFO] Creating private link (%s) in HVN (%s)", privateLinkID, hvnID)
	privateLinkResponse, err := clients.CreatePrivateLinkService(ctx, client, privateLinkService)
	if err != nil {
		return diag.Errorf("unable to create private link (%s): %v", privateLinkID, err)
	}

	// Set the globally unique id of this private link in the state now since it has been created
	link := newLink(privateLinkService.Hvn.Location, PrivateLinkResourceType, privateLinkService.ID)
	url, err := linkURL(link)
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(url)

	// Wait for private link to be created
	if err := clients.WaitForOperation(ctx, client, "create private link", loc, privateLinkResponse.Operation.ID); err != nil {
		return diag.Errorf("unable to create private link (%s): %v", privateLinkID, err)
	}
	log.Printf("[INFO] Created private link (%s)", privateLinkID)

	// Wait for the private link to be available
	privateLinkService, err = clients.WaitForPrivateLinkServiceToBeAvailable(ctx, client, privateLinkID, hvnID, loc, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return diag.FromErr(err)
	}
	log.Printf("[INFO] Private link (%s) is now in AVAILABLE state", privateLinkID)

	// On initial creation, make sure to preserve the hvn_id that was passed in
	if err := d.Set("hvn_id", hvnID); err != nil {
		return diag.FromErr(err)
	}

	if err := setPrivateLinkResourceData(d, privateLinkService); err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourcePrivateLinkRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*clients.Client)

	privateLinkID := d.Get("private_link_id").(string)
	hvnID := d.Get("hvn_id").(string)
	projectID, err := GetProjectID(d.Get("project_id").(string), client.Config.ProjectID)
	if err != nil {
		return diag.Errorf("unable to retrieve project ID: %v", err)
	}

	loc := &sharedmodels.HashicorpCloudLocationLocation{
		OrganizationID: client.Config.OrganizationID,
		ProjectID:      projectID,
	}

	log.Printf("[INFO] Reading private link (%s)", privateLinkID)
	privateLinkService, err := clients.GetPrivateLinkServiceByID(ctx, client, privateLinkID, hvnID, loc)
	if err != nil {
		if clients.IsResponseCodeNotFound(err) {
			log.Printf("[WARN] Private link (%s) not found, removing from state", privateLinkID)
			d.SetId("")
			return nil
		}
		return diag.Errorf("unable to retrieve private link (%s): %v", privateLinkID, err)
	}

	// Private link found, update resource data
	if err := setPrivateLinkResourceData(d, privateLinkService); err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourcePrivateLinkUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*clients.Client)

	privateLinkID := d.Get("private_link_id").(string)
	hvnID := d.Get("hvn_id").(string)
	projectID, err := GetProjectID(d.Get("project_id").(string), client.Config.ProjectID)
	if err != nil {
		return diag.Errorf("unable to retrieve project ID: %v", err)
	}

	loc := &sharedmodels.HashicorpCloudLocationLocation{
		OrganizationID: client.Config.OrganizationID,
		ProjectID:      projectID,
	}

	// Get the HVN to get its region information for the location
	hvn, err := clients.GetHvnByID(ctx, client, loc, hvnID)
	if err != nil {
		return diag.Errorf("unable to retrieve HVN (%s): %v", hvnID, err)
	}

	// Make sure the location has the region information
	loc.Region = &sharedmodels.HashicorpCloudLocationRegion{
		Provider: hvn.Location.Region.Provider,
		Region:   hvn.Location.Region.Region,
	}

	// Handle consumer regions update
	var addConsumerRegions, removeConsumerRegions []string
	if d.HasChange("consumer_regions") {
		old, new := d.GetChange("consumer_regions")
		oldSet := make(map[string]bool)
		for _, v := range old.([]interface{}) {
			if v != nil {
				oldSet[v.(string)] = true
			}
		}
		newSet := make(map[string]bool)
		for _, v := range new.([]interface{}) {
			if v != nil {
				newSet[v.(string)] = true
			}
		}

		// Get the default region (HVN region) if available
		defaultRegion := ""
		if v, ok := d.GetOk("default_region"); ok {
			defaultRegion = v.(string)
		}

		// Determine which regions to add and which to remove
		for region := range newSet {
			if !oldSet[region] {
				// Check if this is the default region
				if defaultRegion != "" && region == defaultRegion {
					// reset to prev state
					resourcePrivateLinkRead(ctx, d, meta)
					// Return an explicit error when attempting to add the default region
					return diag.Errorf("Cannot add default region %q to consumer_regions. The HVN region is automatically included and cannot be added again.", defaultRegion)
				}
				addConsumerRegions = append(addConsumerRegions, region)
			}
		}
		for region := range oldSet {
			if !newSet[region] {
				// Check if this is the default region
				if defaultRegion != "" && region == defaultRegion {
					// reset to prev state
					resourcePrivateLinkRead(ctx, d, meta)
					// Return an explicit error when attempting to remove the default region
					return diag.Errorf("Cannot remove default region %q from consumer_regions. The HVN region is automatically included and cannot be removed.", defaultRegion)
				}
				removeConsumerRegions = append(removeConsumerRegions, region)
			}
		}
	}

	// Handle consumer accounts update
	var addConsumerAccounts, removeConsumerAccounts []string
	if d.HasChange("consumer_accounts") {
		old, new := d.GetChange("consumer_accounts")
		oldSet := make(map[string]bool)
		for _, v := range old.([]interface{}) {
			if v != nil {
				oldSet[v.(string)] = true
			}
		}
		newSet := make(map[string]bool)
		for _, v := range new.([]interface{}) {
			if v != nil {
				newSet[v.(string)] = true
			}
		}

		// Determine which accounts to add and which to remove
		for account := range newSet {
			if !oldSet[account] {
				addConsumerAccounts = append(addConsumerAccounts, account)
			}
		}
		for account := range oldSet {
			if !newSet[account] {
				removeConsumerAccounts = append(removeConsumerAccounts, account)
			}
		}
	}

	// Handle consumer IP ranges update
	var addConsumerIPRanges, removeConsumerIPRanges []string
	if d.HasChange("consumer_ip_ranges") {
		old, new := d.GetChange("consumer_ip_ranges")
		oldSet := make(map[string]bool)
		for _, v := range old.([]interface{}) {
			if v != nil {
				oldSet[v.(string)] = true
			}
		}
		newSet := make(map[string]bool)
		for _, v := range new.([]interface{}) {
			if v != nil {
				newSet[v.(string)] = true
			}
		}

		// Determine which IP ranges to add and which to remove
		for ipRange := range newSet {
			if !oldSet[ipRange] {
				addConsumerIPRanges = append(addConsumerIPRanges, ipRange)
			}
		}
		for ipRange := range oldSet {
			if !newSet[ipRange] {
				removeConsumerIPRanges = append(removeConsumerIPRanges, ipRange)
			}
		}
	}

	// If nothing to update, skip the update call
	if len(addConsumerRegions) == 0 && len(removeConsumerRegions) == 0 &&
		len(addConsumerAccounts) == 0 && len(removeConsumerAccounts) == 0 &&
		len(addConsumerIPRanges) == 0 && len(removeConsumerIPRanges) == 0 {
		return resourcePrivateLinkRead(ctx, d, meta)
	}

	log.Printf("[INFO] Updating private link (%s)", privateLinkID)
	updateResponse, err := clients.UpdatePrivateLinkService(ctx, client, privateLinkID, hvnID, loc,
		addConsumerRegions, removeConsumerRegions, addConsumerAccounts, removeConsumerAccounts, addConsumerIPRanges, removeConsumerIPRanges)
	if err != nil {
		// reset to prev state
		resourcePrivateLinkRead(ctx, d, meta)
		return diag.Errorf("unable to update private link (%s): %v", privateLinkID, err)
	}

	// Wait for the update operation to complete
	if err := clients.WaitForOperation(ctx, client, "update private link", loc, updateResponse.Operation.ID); err != nil {
		// reset to prev state
		resourcePrivateLinkRead(ctx, d, meta)
		return diag.Errorf("unable to update private link (%s): %v", privateLinkID, err)
	}
	log.Printf("[INFO] Updated private link (%s)", privateLinkID)

	// Wait for the private link to be available
	privateLinkService, err := clients.WaitForPrivateLinkServiceToBeAvailable(ctx, client, privateLinkID, hvnID, loc, d.Timeout(schema.TimeoutUpdate))
	if err != nil {
		// reset to prev state
		resourcePrivateLinkRead(ctx, d, meta)
		return diag.FromErr(err)
	}
	log.Printf("[INFO] Private link (%s) is now in AVAILABLE state", privateLinkID)

	// During update, make sure to preserve the hvn_id that was passed in
	if err := d.Set("hvn_id", hvnID); err != nil {
		return diag.FromErr(err)
	}

	if err := setPrivateLinkResourceData(d, privateLinkService); err != nil {
		// reset to prev state
		resourcePrivateLinkRead(ctx, d, meta)
		return diag.FromErr(err)
	}

	return nil
}

func resourcePrivateLinkDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*clients.Client)

	privateLinkID := d.Get("private_link_id").(string)
	hvnID := d.Get("hvn_id").(string)
	projectID, err := GetProjectID(d.Get("project_id").(string), client.Config.ProjectID)
	if err != nil {
		return diag.Errorf("unable to retrieve project ID: %v", err)
	}

	loc := &sharedmodels.HashicorpCloudLocationLocation{
		OrganizationID: client.Config.OrganizationID,
		ProjectID:      projectID,
	}

	log.Printf("[INFO] Deleting private link (%s)", privateLinkID)
	deleteResponse, err := clients.DeletePrivateLinkServiceByID(ctx, client, privateLinkID, hvnID, loc)
	if err != nil {
		if clients.IsResponseCodeNotFound(err) {
			log.Printf("[WARN] Private link (%s) not found, so no action was taken", privateLinkID)
			return nil
		}
		return diag.Errorf("unable to delete private link (%s): %v", privateLinkID, err)
	}

	// Wait for the delete operation to complete
	if err := clients.WaitForOperation(ctx, client, "delete private link", loc, deleteResponse.Operation.ID); err != nil {
		if strings.Contains(err.Error(), "execution already started") {
			return nil
		}
		return diag.Errorf("unable to delete private link (%s): %v", privateLinkID, err)
	}

	log.Printf("[INFO] Private link (%s) deleted, removing from state", privateLinkID)
	return nil
}

func resourcePrivateLinkImport(ctx context.Context, d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	// with multi-projects, import arguments must become dynamic:
	// use explicit project ID with terraform import:
	//   terraform import hcp_private_link.test {project_id}:{hvn_id}:{private_link_id}
	// use default project ID from provider:
	//   terraform import hcp_private_link.test {hvn_id}:{private_link_id}

	client := meta.(*clients.Client)
	projectID, hvnID, privateLinkID, err := parsePrivateLinkResourceID(d.Id(), client.Config.ProjectID)
	if err != nil {
		return nil, err
	}

	loc := &sharedmodels.HashicorpCloudLocationLocation{
		ProjectID:      projectID,
		OrganizationID: client.Config.OrganizationID,
	}

	link := newLink(loc, PrivateLinkResourceType, privateLinkID)
	url, err := linkURL(link)
	if err != nil {
		return nil, err
	}

	d.SetId(url)
	if err := d.Set("project_id", projectID); err != nil {
		return nil, err
	}
	if err := d.Set("hvn_id", hvnID); err != nil {
		return nil, err
	}
	if err := d.Set("private_link_id", privateLinkID); err != nil {
		return nil, err
	}

	return []*schema.ResourceData{d}, nil
}

func setPrivateLinkResourceData(d *schema.ResourceData, privateLinkService *networkmodels.HashicorpCloudNetwork20200907PrivateLinkService) error {
	if err := d.Set("private_link_id", privateLinkService.ID); err != nil {
		return err
	}

	if err := d.Set("organization_id", privateLinkService.Hvn.Location.OrganizationID); err != nil {
		return err
	}

	if err := d.Set("project_id", privateLinkService.Hvn.Location.ProjectID); err != nil {
		return err
	}

	if err := d.Set("vault_cluster_id", privateLinkService.VaultClusterID); err != nil {
		return err
	}

	if err := d.Set("created_at", privateLinkService.CreatedAt.String()); err != nil {
		return err
	}

	if err := d.Set("updated_at", privateLinkService.UpdatedAt.String()); err != nil {
		return err
	}

	if err := d.Set("state", privateLinkService.State); err != nil {
		return err
	}

	if err := d.Set("external_name", privateLinkService.ExternalName); err != nil {
		return err
	}

	// Set the default_region from the model if it exists
	if privateLinkService.DefaultRegion != "" {
		if err := d.Set("default_region", privateLinkService.DefaultRegion); err != nil {
			return err
		}
	}

	// Set consumer regions
	if err := d.Set("consumer_regions", privateLinkService.ConsumerRegions); err != nil {
		return err
	}

	if err := d.Set("consumer_accounts", privateLinkService.ConsumerAccounts); err != nil {
		return err
	}

	if err := d.Set("consumer_ip_ranges", privateLinkService.ConsumerIPRanges); err != nil {
		return err
	}

	link := newLink(privateLinkService.Hvn.Location, PrivateLinkResourceType, privateLinkService.ID)
	selfLink, err := linkURL(link)
	if err != nil {
		return err
	}
	if err := d.Set("self_link", selfLink); err != nil {
		return err
	}

	return nil
}
